//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from './components/api-authorization/followIfLoginRedirect';

export class AuthClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  login(command: LoginCommand): Promise<AccountDto> {
    let url_ = this.baseUrl + '/api/Auth/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogin(_response);
    });
  }

  protected processLogin(response: Response): Promise<AccountDto> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AccountDto.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AccountDto>(null as any);
  }

  logout(command: LogoutCommand): Promise<void> {
    let url_ = this.baseUrl + '/api/Auth/logout';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogout(_response);
    });
  }

  protected processLogout(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class TodoItemsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getTodoItemsWithPagination(
    listId: number,
    pageNumber: number,
    pageSize: number
  ): Promise<PaginatedListOfTodoItemBriefDto> {
    let url_ = this.baseUrl + '/api/TodoItems?';
    if (listId === undefined || listId === null)
      throw new Error(
        "The parameter 'listId' must be defined and cannot be null."
      );
    else url_ += 'ListId=' + encodeURIComponent('' + listId) + '&';
    if (pageNumber === undefined || pageNumber === null)
      throw new Error(
        "The parameter 'pageNumber' must be defined and cannot be null."
      );
    else url_ += 'PageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (pageSize === undefined || pageSize === null)
      throw new Error(
        "The parameter 'pageSize' must be defined and cannot be null."
      );
    else url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTodoItemsWithPagination(_response);
    });
  }

  protected processGetTodoItemsWithPagination(
    response: Response
  ): Promise<PaginatedListOfTodoItemBriefDto> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<PaginatedListOfTodoItemBriefDto>(null as any);
  }

  createTodoItem(command: CreateTodoItemCommand): Promise<number> {
    let url_ = this.baseUrl + '/api/TodoItems';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateTodoItem(_response);
    });
  }

  protected processCreateTodoItem(response: Response): Promise<number> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  updateTodoItem(id: number, command: UpdateTodoItemCommand): Promise<void> {
    let url_ = this.baseUrl + '/api/TodoItems/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTodoItem(_response);
    });
  }

  protected processUpdateTodoItem(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  deleteTodoItem(id: number): Promise<void> {
    let url_ = this.baseUrl + '/api/TodoItems/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteTodoItem(_response);
    });
  }

  protected processDeleteTodoItem(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  updateTodoItemDetail(
    id: number,
    command: UpdateTodoItemDetailCommand
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/TodoItems/UpdateDetail/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTodoItemDetail(_response);
    });
  }

  protected processUpdateTodoItemDetail(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class TodoListsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getTodoLists(): Promise<TodosVm> {
    let url_ = this.baseUrl + '/api/TodoLists';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTodoLists(_response);
    });
  }

  protected processGetTodoLists(response: Response): Promise<TodosVm> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TodosVm.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TodosVm>(null as any);
  }

  createTodoList(command: CreateTodoListCommand): Promise<number> {
    let url_ = this.baseUrl + '/api/TodoLists';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateTodoList(_response);
    });
  }

  protected processCreateTodoList(response: Response): Promise<number> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<number>(null as any);
  }

  updateTodoList(id: number, command: UpdateTodoListCommand): Promise<void> {
    let url_ = this.baseUrl + '/api/TodoLists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTodoList(_response);
    });
  }

  protected processUpdateTodoList(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  deleteTodoList(id: number): Promise<void> {
    let url_ = this.baseUrl + '/api/TodoLists/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteTodoList(_response);
    });
  }

  protected processDeleteTodoList(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class WeatherForecastsClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  getWeatherForecasts(): Promise<WeatherForecast[]> {
    let url_ = this.baseUrl + '/api/WeatherForecasts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetWeatherForecasts(_response);
    });
  }

  protected processGetWeatherForecasts(
    response: Response
  ): Promise<WeatherForecast[]> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(WeatherForecast.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<WeatherForecast[]>(null as any);
  }
}

export class Client {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: {
      fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  postRegister(registration: RegisterRequest | undefined): Promise<void> {
    let url_ = this.baseUrl + '/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(registration);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostRegister(_response);
    });
  }

  protected processPostRegister(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postLogin(
    useCookies: boolean | null | undefined,
    useSessionCookies: boolean | null | undefined,
    login: LoginRequest | undefined
  ): Promise<AccessTokenResponse> {
    let url_ = this.baseUrl + '/login?';
    if (useCookies !== undefined && useCookies !== null)
      url_ += 'useCookies=' + encodeURIComponent('' + useCookies) + '&';
    if (useSessionCookies !== undefined && useSessionCookies !== null)
      url_ +=
        'useSessionCookies=' + encodeURIComponent('' + useSessionCookies) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(login);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostLogin(_response);
    });
  }

  protected processPostLogin(response: Response): Promise<AccessTokenResponse> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AccessTokenResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AccessTokenResponse>(null as any);
  }

  postRefresh(
    refreshRequest: RefreshRequest | undefined
  ): Promise<AccessTokenResponse> {
    let url_ = this.baseUrl + '/refresh';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(refreshRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostRefresh(_response);
    });
  }

  protected processPostRefresh(
    response: Response
  ): Promise<AccessTokenResponse> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AccessTokenResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<AccessTokenResponse>(null as any);
  }

  getConfirmEmail(
    userId: string | null | undefined,
    code: string | null | undefined,
    changedEmail: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/confirmEmail?';
    if (userId !== undefined && userId !== null)
      url_ += 'userId=' + encodeURIComponent('' + userId) + '&';
    if (code !== undefined && code !== null)
      url_ += 'code=' + encodeURIComponent('' + code) + '&';
    if (changedEmail !== undefined && changedEmail !== null)
      url_ += 'changedEmail=' + encodeURIComponent('' + changedEmail) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetConfirmEmail(_response);
    });
  }

  protected processGetConfirmEmail(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postResendConfirmationEmail(
    resendRequest: ResendConfirmationEmailRequest | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/resendConfirmationEmail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(resendRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostResendConfirmationEmail(_response);
    });
  }

  protected processPostResendConfirmationEmail(
    response: Response
  ): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postForgotPassword(
    resetRequest: ForgotPasswordRequest | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/forgotPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(resetRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostForgotPassword(_response);
    });
  }

  protected processPostForgotPassword(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postResetPassword(
    resetRequest: ResetPasswordRequest | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/resetPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(resetRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostResetPassword(_response);
    });
  }

  protected processPostResetPassword(response: Response): Promise<void> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  postManage2fa(
    tfaRequest: TwoFactorRequest | undefined
  ): Promise<TwoFactorResponse> {
    let url_ = this.baseUrl + '/manage/2fa';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(tfaRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostManage2fa(_response);
    });
  }

  protected processPostManage2fa(
    response: Response
  ): Promise<TwoFactorResponse> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TwoFactorResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TwoFactorResponse>(null as any);
  }

  getManageInfo(): Promise<InfoResponse> {
    let url_ = this.baseUrl + '/manage/info';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetManageInfo(_response);
    });
  }

  protected processGetManageInfo(response: Response): Promise<InfoResponse> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InfoResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InfoResponse>(null as any);
  }

  postManageInfo(infoRequest: InfoRequest | undefined): Promise<InfoResponse> {
    let url_ = this.baseUrl + '/manage/info';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(infoRequest);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostManageInfo(_response);
    });
  }

  protected processPostManageInfo(response: Response): Promise<InfoResponse> {
    followIfLoginRedirect(response);
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InfoResponse.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = HttpValidationProblemDetails.fromJS(resultData400);
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException(
          'A server side error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<InfoResponse>(null as any);
  }
}

export class AccountDto implements IAccountDto {
  id?: string | undefined;
  token?: string | undefined;
  userName?: string | undefined;
  type?: string | undefined;
  fullName?: string | undefined;
  staffCode?: string | undefined;
  location?: string | undefined;
  isNewUser?: string | undefined;

  constructor(data?: IAccountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.token = _data['token'];
      this.userName = _data['userName'];
      this.type = _data['type'];
      this.fullName = _data['fullName'];
      this.staffCode = _data['staffCode'];
      this.location = _data['location'];
      this.isNewUser = _data['isNewUser'];
    }
  }

  static fromJS(data: any): AccountDto {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['token'] = this.token;
    data['userName'] = this.userName;
    data['type'] = this.type;
    data['fullName'] = this.fullName;
    data['staffCode'] = this.staffCode;
    data['location'] = this.location;
    data['isNewUser'] = this.isNewUser;
    return data;
  }
}

export interface IAccountDto {
  id?: string | undefined;
  token?: string | undefined;
  userName?: string | undefined;
  type?: string | undefined;
  fullName?: string | undefined;
  staffCode?: string | undefined;
  location?: string | undefined;
  isNewUser?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
  userName?: string;
  password?: string;

  constructor(data?: ILoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data['userName'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userName'] = this.userName;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginCommand {
  userName?: string;
  password?: string;
}

export class LogoutCommand implements ILogoutCommand {
  constructor(data?: ILogoutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): LogoutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LogoutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface ILogoutCommand {}

export class PaginatedListOfTodoItemBriefDto
  implements IPaginatedListOfTodoItemBriefDto
{
  items?: TodoItemBriefDto[];
  pageNumber?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPaginatedListOfTodoItemBriefDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(TodoItemBriefDto.fromJS(item));
      }
      this.pageNumber = _data['pageNumber'];
      this.totalPages = _data['totalPages'];
      this.totalCount = _data['totalCount'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTodoItemBriefDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    data['pageNumber'] = this.pageNumber;
    data['totalPages'] = this.totalPages;
    data['totalCount'] = this.totalCount;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPaginatedListOfTodoItemBriefDto {
  items?: TodoItemBriefDto[];
  pageNumber?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;

  constructor(data?: ITodoItemBriefDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.listId = _data['listId'];
      this.title = _data['title'];
      this.done = _data['done'];
    }
  }

  static fromJS(data: any): TodoItemBriefDto {
    data = typeof data === 'object' ? data : {};
    let result = new TodoItemBriefDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['listId'] = this.listId;
    data['title'] = this.title;
    data['done'] = this.done;
    return data;
  }
}

export interface ITodoItemBriefDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
  listId?: number;
  title?: string | undefined;

  constructor(data?: ICreateTodoItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.listId = _data['listId'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): CreateTodoItemCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTodoItemCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['listId'] = this.listId;
    data['title'] = this.title;
    return data;
  }
}

export interface ICreateTodoItemCommand {
  listId?: number;
  title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
  id?: number;
  title?: string | undefined;
  done?: boolean;

  constructor(data?: IUpdateTodoItemCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.done = _data['done'];
    }
  }

  static fromJS(data: any): UpdateTodoItemCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTodoItemCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['done'] = this.done;
    return data;
  }
}

export interface IUpdateTodoItemCommand {
  id?: number;
  title?: string | undefined;
  done?: boolean;
}

export class UpdateTodoItemDetailCommand
  implements IUpdateTodoItemDetailCommand
{
  id?: number;
  listId?: number;
  priority?: PriorityLevel;
  note?: string | undefined;

  constructor(data?: IUpdateTodoItemDetailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.listId = _data['listId'];
      this.priority = _data['priority'];
      this.note = _data['note'];
    }
  }

  static fromJS(data: any): UpdateTodoItemDetailCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTodoItemDetailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['listId'] = this.listId;
    data['priority'] = this.priority;
    data['note'] = this.note;
    return data;
  }
}

export interface IUpdateTodoItemDetailCommand {
  id?: number;
  listId?: number;
  priority?: PriorityLevel;
  note?: string | undefined;
}

export enum PriorityLevel {
  None = 0,
  Low = 1,
  Medium = 2,
  High = 3,
}

export class TodosVm implements ITodosVm {
  priorityLevels?: LookupDto[];
  lists?: TodoListDto[];

  constructor(data?: ITodosVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['priorityLevels'])) {
        this.priorityLevels = [] as any;
        for (let item of _data['priorityLevels'])
          this.priorityLevels!.push(LookupDto.fromJS(item));
      }
      if (Array.isArray(_data['lists'])) {
        this.lists = [] as any;
        for (let item of _data['lists'])
          this.lists!.push(TodoListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TodosVm {
    data = typeof data === 'object' ? data : {};
    let result = new TodosVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.priorityLevels)) {
      data['priorityLevels'] = [];
      for (let item of this.priorityLevels)
        data['priorityLevels'].push(item.toJSON());
    }
    if (Array.isArray(this.lists)) {
      data['lists'] = [];
      for (let item of this.lists) data['lists'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITodosVm {
  priorityLevels?: LookupDto[];
  lists?: TodoListDto[];
}

export class LookupDto implements ILookupDto {
  id?: number;
  title?: string | undefined;

  constructor(data?: ILookupDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): LookupDto {
    data = typeof data === 'object' ? data : {};
    let result = new LookupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    return data;
  }
}

export interface ILookupDto {
  id?: number;
  title?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
  id?: number;
  title?: string | undefined;
  colour?: string | undefined;
  items?: TodoItemDto[];

  constructor(data?: ITodoListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.colour = _data['colour'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(TodoItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TodoListDto {
    data = typeof data === 'object' ? data : {};
    let result = new TodoListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['colour'] = this.colour;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface ITodoListDto {
  id?: number;
  title?: string | undefined;
  colour?: string | undefined;
  items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;
  priority?: number;
  note?: string | undefined;

  constructor(data?: ITodoItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.listId = _data['listId'];
      this.title = _data['title'];
      this.done = _data['done'];
      this.priority = _data['priority'];
      this.note = _data['note'];
    }
  }

  static fromJS(data: any): TodoItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new TodoItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['listId'] = this.listId;
    data['title'] = this.title;
    data['done'] = this.done;
    data['priority'] = this.priority;
    data['note'] = this.note;
    return data;
  }
}

export interface ITodoItemDto {
  id?: number;
  listId?: number;
  title?: string | undefined;
  done?: boolean;
  priority?: number;
  note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
  title?: string | undefined;

  constructor(data?: ICreateTodoListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): CreateTodoListCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateTodoListCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    return data;
  }
}

export interface ICreateTodoListCommand {
  title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
  id?: number;
  title?: string | undefined;

  constructor(data?: IUpdateTodoListCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): UpdateTodoListCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateTodoListCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    return data;
  }
}

export interface IUpdateTodoListCommand {
  id?: number;
  title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
  date?: Date;
  temperatureC?: number;
  temperatureF?: number;
  summary?: string | undefined;

  constructor(data?: IWeatherForecast) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date']
        ? new Date(_data['date'].toString())
        : <any>undefined;
      this.temperatureC = _data['temperatureC'];
      this.temperatureF = _data['temperatureF'];
      this.summary = _data['summary'];
    }
  }

  static fromJS(data: any): WeatherForecast {
    data = typeof data === 'object' ? data : {};
    let result = new WeatherForecast();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['temperatureC'] = this.temperatureC;
    data['temperatureF'] = this.temperatureF;
    data['summary'] = this.summary;
    return data;
  }
}

export interface IWeatherForecast {
  date?: Date;
  temperatureC?: number;
  temperatureF?: number;
  summary?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export class HttpValidationProblemDetails
  extends ProblemDetails
  implements IHttpValidationProblemDetails
{
  errors?: { [key: string]: string[] };

  [key: string]: any;

  constructor(data?: IHttpValidationProblemDetails) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static override fromJS(data: any): HttpValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new HttpValidationProblemDetails();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = (<any>this.errors)[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
  errors?: { [key: string]: string[] };

  [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
  email?: string;
  password?: string;

  constructor(data?: IRegisterRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): RegisterRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface IRegisterRequest {
  email?: string;
  password?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
  tokenType?: string;
  accessToken?: string;
  expiresIn?: number;
  refreshToken?: string;

  constructor(data?: IAccessTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tokenType = _data['tokenType'];
      this.accessToken = _data['accessToken'];
      this.expiresIn = _data['expiresIn'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): AccessTokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AccessTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tokenType'] = this.tokenType;
    data['accessToken'] = this.accessToken;
    data['expiresIn'] = this.expiresIn;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IAccessTokenResponse {
  tokenType?: string;
  accessToken?: string;
  expiresIn?: number;
  refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
  email?: string;
  password?: string;
  twoFactorCode?: string | undefined;
  twoFactorRecoveryCode?: string | undefined;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
      this.twoFactorCode = _data['twoFactorCode'];
      this.twoFactorRecoveryCode = _data['twoFactorRecoveryCode'];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    data['twoFactorCode'] = this.twoFactorCode;
    data['twoFactorRecoveryCode'] = this.twoFactorRecoveryCode;
    return data;
  }
}

export interface ILoginRequest {
  email?: string;
  password?: string;
  twoFactorCode?: string | undefined;
  twoFactorRecoveryCode?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
  refreshToken?: string;

  constructor(data?: IRefreshRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshRequest {
  refreshToken?: string;
}

export class ResendConfirmationEmailRequest
  implements IResendConfirmationEmailRequest
{
  email?: string;

  constructor(data?: IResendConfirmationEmailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ResendConfirmationEmailRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ResendConfirmationEmailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IResendConfirmationEmailRequest {
  email?: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
  email?: string;

  constructor(data?: IForgotPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ForgotPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ForgotPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IForgotPasswordRequest {
  email?: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
  email?: string;
  resetCode?: string;
  newPassword?: string;

  constructor(data?: IResetPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.resetCode = _data['resetCode'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['resetCode'] = this.resetCode;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IResetPasswordRequest {
  email?: string;
  resetCode?: string;
  newPassword?: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
  sharedKey?: string;
  recoveryCodesLeft?: number;
  recoveryCodes?: string[] | undefined;
  isTwoFactorEnabled?: boolean;
  isMachineRemembered?: boolean;

  constructor(data?: ITwoFactorResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sharedKey = _data['sharedKey'];
      this.recoveryCodesLeft = _data['recoveryCodesLeft'];
      if (Array.isArray(_data['recoveryCodes'])) {
        this.recoveryCodes = [] as any;
        for (let item of _data['recoveryCodes']) this.recoveryCodes!.push(item);
      }
      this.isTwoFactorEnabled = _data['isTwoFactorEnabled'];
      this.isMachineRemembered = _data['isMachineRemembered'];
    }
  }

  static fromJS(data: any): TwoFactorResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TwoFactorResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sharedKey'] = this.sharedKey;
    data['recoveryCodesLeft'] = this.recoveryCodesLeft;
    if (Array.isArray(this.recoveryCodes)) {
      data['recoveryCodes'] = [];
      for (let item of this.recoveryCodes) data['recoveryCodes'].push(item);
    }
    data['isTwoFactorEnabled'] = this.isTwoFactorEnabled;
    data['isMachineRemembered'] = this.isMachineRemembered;
    return data;
  }
}

export interface ITwoFactorResponse {
  sharedKey?: string;
  recoveryCodesLeft?: number;
  recoveryCodes?: string[] | undefined;
  isTwoFactorEnabled?: boolean;
  isMachineRemembered?: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
  enable?: boolean | undefined;
  twoFactorCode?: string | undefined;
  resetSharedKey?: boolean;
  resetRecoveryCodes?: boolean;
  forgetMachine?: boolean;

  constructor(data?: ITwoFactorRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.enable = _data['enable'];
      this.twoFactorCode = _data['twoFactorCode'];
      this.resetSharedKey = _data['resetSharedKey'];
      this.resetRecoveryCodes = _data['resetRecoveryCodes'];
      this.forgetMachine = _data['forgetMachine'];
    }
  }

  static fromJS(data: any): TwoFactorRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TwoFactorRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['enable'] = this.enable;
    data['twoFactorCode'] = this.twoFactorCode;
    data['resetSharedKey'] = this.resetSharedKey;
    data['resetRecoveryCodes'] = this.resetRecoveryCodes;
    data['forgetMachine'] = this.forgetMachine;
    return data;
  }
}

export interface ITwoFactorRequest {
  enable?: boolean | undefined;
  twoFactorCode?: string | undefined;
  resetSharedKey?: boolean;
  resetRecoveryCodes?: boolean;
  forgetMachine?: boolean;
}

export class InfoResponse implements IInfoResponse {
  email?: string;
  isEmailConfirmed?: boolean;

  constructor(data?: IInfoResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.isEmailConfirmed = _data['isEmailConfirmed'];
    }
  }

  static fromJS(data: any): InfoResponse {
    data = typeof data === 'object' ? data : {};
    let result = new InfoResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['isEmailConfirmed'] = this.isEmailConfirmed;
    return data;
  }
}

export interface IInfoResponse {
  email?: string;
  isEmailConfirmed?: boolean;
}

export class InfoRequest implements IInfoRequest {
  newEmail?: string | undefined;
  newPassword?: string | undefined;
  oldPassword?: string | undefined;

  constructor(data?: IInfoRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.newEmail = _data['newEmail'];
      this.newPassword = _data['newPassword'];
      this.oldPassword = _data['oldPassword'];
    }
  }

  static fromJS(data: any): InfoRequest {
    data = typeof data === 'object' ? data : {};
    let result = new InfoRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['newEmail'] = this.newEmail;
    data['newPassword'] = this.newPassword;
    data['oldPassword'] = this.oldPassword;
    return data;
  }
}

export interface IInfoRequest {
  newEmail?: string | undefined;
  newPassword?: string | undefined;
  oldPassword?: string | undefined;
}

export class SwaggerException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new SwaggerException(message, status, response, headers, null);
}
